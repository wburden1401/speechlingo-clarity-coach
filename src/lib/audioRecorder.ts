
interface AudioRecorderOptions {
  onDataAvailable?: (blob: Blob) => void;
  onTimeUpdate?: (time: number) => void;
  onComplete?: (blob: Blob, duration: number) => void;
  onError?: (error: Error) => void;
  maxDuration?: number; // in seconds
}

export class AudioRecorder {
  private mediaRecorder: MediaRecorder | null = null;
  private audioChunks: Blob[] = [];
  private startTime: number = 0;
  private timerInterval: number | null = null;
  private timeElapsed: number = 0;
  private maxDuration: number = 0;
  private stream: MediaStream | null = null;

  // Callback functions
  private onDataAvailable: ((blob: Blob) => void) | undefined;
  private onTimeUpdate: ((time: number) => void) | undefined;
  private onComplete: ((blob: Blob, duration: number) => void) | undefined;
  private onError: ((error: Error) => void) | undefined;

  constructor(options?: AudioRecorderOptions) {
    this.onDataAvailable = options?.onDataAvailable;
    this.onTimeUpdate = options?.onTimeUpdate;
    this.onComplete = options?.onComplete;
    this.onError = options?.onError;
    this.maxDuration = options?.maxDuration || 0;
  }

  public async start(): Promise<void> {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      this.mediaRecorder = new MediaRecorder(this.stream);
      this.audioChunks = [];
      this.startTime = Date.now();
      this.timeElapsed = 0;

      this.mediaRecorder.addEventListener('dataavailable', this.handleDataAvailable);
      this.mediaRecorder.addEventListener('stop', this.handleStop);
      
      this.mediaRecorder.start(100); // Collect data every 100ms
      
      // Start timer
      if (this.onTimeUpdate) {
        this.timerInterval = window.setInterval(() => {
          this.timeElapsed = Math.floor((Date.now() - this.startTime) / 1000);
          this.onTimeUpdate?.(this.timeElapsed);
          
          // Auto-stop if max duration is reached
          if (this.maxDuration > 0 && this.timeElapsed >= this.maxDuration) {
            this.stop();
          }
        }, 100);
      }
    } catch (error) {
      if (this.onError) {
        this.onError(error as Error);
      }
      console.error('Error starting recording:', error);
    }
  }

  public stop(): void {
    if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
      this.mediaRecorder.stop();
    }
    
    // Clear timer
    if (this.timerInterval) {
      clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
    
    // Stop all tracks in the stream
    if (this.stream) {
      this.stream.getTracks().forEach(track => track.stop());
      this.stream = null;
    }
  }

  public isRecording(): boolean {
    return this.mediaRecorder !== null && this.mediaRecorder.state === 'recording';
  }

  private handleDataAvailable = (event: BlobEvent): void => {
    if (event.data.size > 0) {
      this.audioChunks.push(event.data);
      
      if (this.onDataAvailable) {
        this.onDataAvailable(event.data);
      }
    }
  };

  private handleStop = (): void => {
    const duration = Math.floor((Date.now() - this.startTime) / 1000);
    const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
    
    if (this.onComplete) {
      this.onComplete(audioBlob, duration);
    }
    
    // Clean up
    this.mediaRecorder?.removeEventListener('dataavailable', this.handleDataAvailable);
    this.mediaRecorder?.removeEventListener('stop', this.handleStop);
    this.mediaRecorder = null;
    this.audioChunks = [];
    this.timeElapsed = 0;
  };
}

// Mock audio analysis service 
export const analyzeAudio = async (audioBlob: Blob): Promise<{
  transcript: string;
  fillerWordCount: number;
  paceWordsPerMinute: number;
  clarity: number; // 0-100
  confidence: number; // 0-100
}> => {
  // This would actually send the audio to a server for analysis
  // For now, we're returning mock data
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        transcript: "This is a mock transcript of what the user said. It would normally be generated by a speech recognition service.",
        fillerWordCount: Math.floor(Math.random() * 8),
        paceWordsPerMinute: Math.floor(Math.random() * 40) + 120, // 120-160 wpm
        clarity: Math.floor(Math.random() * 30) + 70, // 70-100
        confidence: Math.floor(Math.random() * 30) + 70, // 70-100
      });
    }, 1500);
  });
};
